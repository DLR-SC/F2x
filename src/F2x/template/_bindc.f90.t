{#
	F2x template for Fortran
	
	This template uses the Fortran BIND(C) feature to generate a nice interface that
	can be called from C.
#}
{##### Macros #####}

{# Derived type access variables #}
{%- macro type_var_decl(type) -%}
		TYPE(C_PTR), VALUE, INTENT(IN) :: {{ type.name }}_INST
		TYPE({{ type.name }}), POINER :: {{ type.name }}_INTERN
{%- endmacro -%}

{# Derived type C -> Fortran #}
{%- macro type_var_cast(type) -%}
		C_F_POINTER({{ type.name }}_INST, {{ type.name }}_INTERN)
{%- endmacro -%}

{%- macro var_decl(var, name, value=False, arg_names=None, intent=None) -%}
		{{ var.type }}
		{%- if value and var.intent != 'OUT' %}, VALUE{% endif -%}
		{%- if var.intent or intent %}, INTENT({{ var.intent or intent }}){% endif -%}
		:: {{ name }}
		{%- if var.ftype %}
		TYPE({{ var.ftype }}), POINTER :: {{ name }}_INTERN
		{%- if arg_names -%}{% do arg_names.append(name, name + '_INTERN') %}{% endif -%}
		{%- endif %}
{%- endmacro -%}

{%- macro var_assign(var, name, value) -%}
		{%- if var.dims -%}
		{{ name }}({{ ', '.join([':'] * var.dims|length) }}) = {{ value }}
		{%- elif var.strlen -%}
		F_C_STRING({{ value }}, {{ var.strlen }}, {{ name }})
		{%- elif var.ftype -%}
		{{ name }}_INTERN => {{ value }}
		{{ name }} = C_LOC({{ name }}_INTERN)
		{%- else -%}
		{{ name }} = {{ value }}
		{%- endif %}
{%- endmacro -%}

{%- macro call_args(args, arg_names={}) -%}
	{%- for arg in args %}
		{%- if arg.name in arg_names %}{{ arg_names[arg.name] }}{% else %}{{ arg.name }}{% endif -%}
		{%- if not loop.last -%}, {%- endif -%}
	{%- endfor -%}
{%- endmacro -%}

{# Template starts here #}
! BIND(C)-based wrapper for {{ context.filename }}{
! This file was generated by F2x. Please do not edit directly.
MODULE {{ module.name }}_BINDC
	USE, INTRINSIC :: ISO_C_BINDING
	USE WRAP_UTIL
{%- for use in module.uses %}
	USE {{ use }}
{%- endfor %}
	USE {{ module.name }}
	
	IMPLICIT NONE
	
	INTEGER, PARAMETER :: LF = 8 ! TODO: Move to configuration

CONTAINS
{##### Interface for derived types #####}
{%- for type in module.types %}
	
	!--------------------------------------------------------------------------
	! Interface for {{ type.name }} from {{ module.name }}.
	!
	FUNCTION {{ type.name }}_NEW() BIND(C, NAME="{{ type.name }}_new")
		TYPE(C_PTR) :: {{ type.name }}_NEW
		TYPE({{ type.name }}), POINTER :: {{ type.name }}_INTERN
		
		ALLOCATE({{ type.name}}_INTERN)
		{{ type.name }}_NEW = C_LOC({{ type.name }}_INTERN)
	END FUNCTION
	
	SUBROUTINE {{ type.name }}_FREE({{ type.name }}_INST) BIND(C, NAME="{{ type.name }}_free")
		{{ type_var_decl(type) }}
		
		{{ type_var_cast(type) }}
		DEALLOCATE({{ type.name }}_INTERN)
	END SUBROUTINE
{%- for field in type.fields %}
{%- set getter_name = type.name + '_get_' + field.name %}
{%- if field.getter == 'function' %}

	FUNCTION {{ getter_name.upper() }}({{ type.name }}_INST) BIND(C, NAME="{{ getter_name }}")
		{{ var_decl(field, getter_name.upper()) }}
		{{ type_var_decl(type) }}
		
		{{ type_var_cast(type) }}
		{{ var_assign(field, getter_name.upper(), type.name + '_INTERN%' + field.name) }}
	END FUNCTION
{%- elif field.getter == 'subroutine' %}

	SUBROUTINE {{ getter_name.upper() }}({{ type.name }}_INST, {{ field.name }}_VALUE) BIND(C, NAME="{{ getter_name }}")
		{{ type_var_decl(type) }}
		{{ var_decl(field, field.name + '_VALUE', intent='OUT') }}

		{{ type_var_cast(type) }}
		{{ var_assign(field, field.name + '_VALUE', type.name + '_INTERN%' + field.name) }}
	END SUBROUTINE
{%- endif %}
{%- if field.setter %}
{%- set setter_name = type.name + '_set_' + field.name %}

	SUBROUTINE {{ setter_name.upper() }}({{ type.name }}_INST, {{ field.name }}_VALUE) BIND(C, NAME="{{ setter_name }}")
		{{ type_var_decl(type) }}
		{{ var_decl(field, field.name + '_VALUE') }}

		{{ type_var_cast(type) }}
		{%- if field.strlen %}
		CALL C_F_STRING({{ field.name }}_VALUE, {{ field.strlen }}, {{ type.name }}_INTERN%{{ field.name }})
		{%- else %}
		{{ type.name }}_INTERN%{{ field.name }} = {{ field.name }}_VALUE
		{%- endif %}
	END SUBROUTINE
{%- endif %}
{%- endfor %}
{%- endfor %}

{%- if config.has_section('export') %}
{%- set exports = config.options('export') %}

	!------------------------------------------------------------
	! Exported functions and subroutines
	!
{%- for function in module.functions %}
{%- if function.name.lower() in exports %}
{%- set export_name = config.get('export', function.name.lower()) %}
{%- set arg_names = {} %}
{%- if function.ret.getter == 'function' %}

	FUNCTION {{ export_name.upper() }}({{ call_args(function.args) }}) BIND(C, NAME="{{ export_name }}")
		{{ var_decl(function.ret, export_name.upper()) }}
	{%- for arg in function.args %}
		{{ var_decl(arg, arg.name, arg_names=arg_names) }}
	{%- endfor %}

	{% for arg in function.args %}
	{%- if arg.strlen %}
		CALL C_F_STRING({{ arg.name }}, {{ arg.strlen }}, {{ arg.name }}_INTERN)
	{%- elif arg.ftype %}
		CALL C_F_POINTER({{ arg.name }}, {{ arg.name }}_INTERN)
	{%- endif %}
	{%- endfor %}
	
		{% if function.ret.ftype -%}
		ALLOCATE({{ function.name.upper() }}_INTERN)
		{%- endif %}
		{{ var_assign(function.ret, export_name.upper(), function.name + '(' + call_args(function.args, arg_names) + ')') }}
	END FUNCTION
{%- elif function.ret.getter == 'subroutine' %}

	SUBROUTINE {{ export_name.upper() }}({{ call_args(function.args) }}, {{ export_name.upper() }}_VALUE) BIND(C, NAME="{{ export_name }}")
	{%- for arg in function.args %}
		{{ var_decl(arg, arg.name, arg_names=arg_names) }}
	{%- endfor %}
		{{ var_decl(function.ret, export_name.upper() + '_VALUE', intent='OUT') }}
	{%- for arg in function.args %}
	{%- if arg.strlen %}
		CALL C_F_STRING({{ arg.name }}, {{ arg.strlen }}, {{ arg.name }}_INTERN)
	{%- elif arg.ftype %}
		CALL C_F_POINTER({{ arg.name }}, {{ arg.name }}_INTERN)
	{%- endif %}
	{%- endfor %}
		{{ var_assign(function.ret, export_name.upper() + '_VALUE', function.name + '(' + call_args(function.args, arg_names) + ')') }}
	END SUBROUTINE
{%- endif %}
{%- endif %}
{%- endfor %}
{%- endif %}
END
