{#-
	F2x template for Fortran
	
	This template uses the Fortran BIND(C) feature to generate a nice interface that
	can be called from C.
-#}

{##### Macros #####}
{#- Derived type access variables -#}
{%- macro type_var_decl(type) -%}
		TYPE(C_PTR), VALUE, INTENT(IN) :: {{ type.name }}_INST
		TYPE({{ type.name }}), POINTER :: {{ type.name }}_INTERN
{%- endmacro -%}

{#- Derived type C -> Fortran -#}
{%- macro type_var_cast(type) -%}
		CALL C_F_POINTER({{ type.name }}_INST, {{ type.name }}_INTERN)
{%- endmacro -%}

{%- macro var_decl(var, name, value=False, arg_names={}, intent=None) -%}
		{{ var.type }}{% if var.kind %}({{ var.kind }}){% endif %}
		{%- if var.dims %}, POINTER
		{%- elif (value and (var.intent == 'IN' or intent == 'INOUT')) or var.strlen %}, VALUE{% endif -%}
		{%- if (var.intent or intent) and not var.strlen %}, INTENT({{ var.intent or intent }})
		{%- endif %} :: {{ name }}
		{%- if var.strlen %}
		CHARACTER({{ var.strlen }}) :: {{ name }}_INTERN
		{%- do arg_names.__setitem__(name, name + '_INTERN') %}
		{%- endif %}
		{%- if var.ftype %}
		TYPE({{ var.ftype }}), POINTER :: {{ name }}_INTERN
		{%- do arg_names.__setitem__(name, name + '_INTERN') %}
		{%- endif %}
		{%- if var.dims %}({% for dim in var.dims %}:{% if not loop.last %}, {% endif %}{% endfor %}){% endif %}
{%- endmacro -%}

{%- macro var_assign(var, name, value, is_call=False) -%}
		{%- if var.dims -%}
		{{ name }} ={% if not is_call %}>{% endif %} {{ value }}
		{%- elif var.strlen -%}
		CALL F_C_STRING_PTR({{ value }}, {{ name }})
		{%- elif var.ftype -%}
		{{ name }}_INTERN ={% if not is_call %}>{% endif %} {{ value }}
		{{ name }} = C_LOC({{ name }}_INTERN)
		{%- else -%}
		{{ name }} = {{ value }}
		{%- endif %}
{%- endmacro -%}

{%- macro call_args(args, arg_names={}) -%}
	{%- for arg in args %}
		{%- if arg.name in arg_names %}{{ arg_names[arg.name] }}{% else %}{{ arg.name }}{% endif -%}
		{%- if not loop.last -%}, {% endif -%}
	{%- endfor -%}
{%- endmacro -%}

{#- Template starts here -#}
! BIND(C)-based wrapper for {{ context.filename }}
! This file was generated by F2x. Please do not edit directly.
MODULE {{ module.name }}_BINDC
	USE, INTRINSIC :: ISO_C_BINDING
	USE C_INTERFACE_MODULE
{%- for use in module.uses %}
	USE {{ use }}
{%- endfor %}
	USE {{ module.name }}
	
	IMPLICIT NONE
	
	INTEGER, PARAMETER :: LF = 8 ! TODO: Move to configuration

CONTAINS
{#- Interface for derived types -#}
{%- for type in module.types %}
	
	!--------------------------------------------------------------------------
	! Interface for {{ type.name }} from {{ module.name }}.
	!
	FUNCTION {{ type.name }}_NEW() BIND(C, NAME="{{ type.name }}_new")
		TYPE(C_PTR) :: {{ type.name }}_NEW
		TYPE({{ type.name }}), POINTER :: {{ type.name }}_INTERN
		
		ALLOCATE({{ type.name }}_INTERN)
		{{ type.name }}_NEW = C_LOC({{ type.name }}_INTERN)
	END FUNCTION
	
	SUBROUTINE {{ type.name }}_FREE({{ type.name }}_INST) BIND(C, NAME="{{ type.name }}_free")
		{{ type_var_decl(type) }}
		
		{{ type_var_cast(type) }}
		DEALLOCATE({{ type.name }}_INTERN)
	END SUBROUTINE
{%- for field in type.fields %}
{%- set getter_name = type.name + '_get_' + field.name %}
{%- if field.getter == 'function' %}

	FUNCTION {{ getter_name.upper() }}({{ type.name }}_INST) BIND(C, NAME="{{ getter_name }}")
		{{ var_decl(field, getter_name.upper()) }}
		{{ type_var_decl(type) }}
		
		{{ type_var_cast(type) }}
		{{ var_assign(field, getter_name.upper(), type.name + '_INTERN%' + field.name) }}
	END FUNCTION
{%- elif field.getter == 'subroutine' %}

	SUBROUTINE {{ getter_name.upper() }}({{ type.name }}_INST, {{ field.name }}_VALUE) BIND(C, NAME="{{ getter_name }}")
		{{ type_var_decl(type) }}
		{{ var_decl(field, field.name + '_VALUE', intent='OUT') }}

		{{ type_var_cast(type) }}
		{{ var_assign(field, field.name + '_VALUE', type.name + '_INTERN%' + field.name) }}
	END SUBROUTINE
{%- endif %}
{%- if field.setter == 'subroutine' %}
{%- set setter_name = type.name + '_set_' + field.name %}

	SUBROUTINE {{ setter_name.upper() }}({{ type.name }}_INST, {{ field.name }}_VALUE) BIND(C, NAME="{{ setter_name }}")
		{{ type_var_decl(type) }}
		{{ var_decl(field, field.name + '_VALUE', value=True, intent='IN') }}

		{{ type_var_cast(type) }}
		{%- if field.strlen %}
		CALL C_F_STRING_PTR({{ field.name }}_VALUE, {{ type.name }}_INTERN%{{ field.name }})
		{%- else %}
		{{ type.name }}_INTERN%{{ field.name }} = {{ field.name }}_VALUE
		{%- endif %}
	END SUBROUTINE
{%- endif %}
{%- endfor %}
{%- endfor %}

{%- if config.has_section('export') %}
{%- set exports = config.options('export') %}

	!------------------------------------------------------------
	! Exported functions and subroutines
	!
{%- for subroutine in module.subroutines %}
{%- if subroutine.name.lower() in exports %}
{%- set export_name = config.get('export', subroutine.name.lower()) %}
{%- set arg_names = {} %}

	SUBROUTINE {{ export_name.upper() }}({{ call_args(subroutine.args) }}) BIND(C, NAME="{{ export_name }}")
	{%- for arg in subroutine.args %}
		{{ var_decl(arg, arg.name, arg_names=arg_names, value=True) }}
	{%- endfor %}
	{%- for arg in subroutine.args %}
	{%- if arg.strlen and arg.intent != 'OUT' %}
		CALL C_F_STRING_PTR({{ arg.name }}, {{ arg.name }}_INTERN)
	{%- elif arg.ftype %}
		CALL C_F_POINTER({{ arg.name }}, {{ arg.name }}_INTERN)
	{%- endif %}
	{%- endfor %}
		CALL {{ subroutine.name }}({{ call_args(subroutine.args, arg_names) }})
	{%- for arg in subroutine.args %}
	{%- if arg.strlen and arg.intent != 'IN' %}
		CALL F_C_STRING_PTR({{ arg.name }}_INTERN, {{ arg.name }})
	{%- endif %}
	{%- endfor %}
	END SUBROUTINE
{%- endif %}
{%- endfor %}

{%- for function in module.functions %}
{%- if function.name.lower() in exports %}
{%- set export_name = config.get('export', function.name.lower()) %}
{%- set arg_names = {} %}
{%- if function.ret.getter == 'function' %}

	FUNCTION {{ export_name.upper() }}({{ call_args(function.args) }}) BIND(C, NAME="{{ export_name }}")
		{{ var_decl(function.ret, export_name.upper()) }}
	{%- for arg in function.args %}
		{{ var_decl(arg, arg.name, arg_names=arg_names, value=True) }}
	{%- endfor %}
	{%- for arg in function.args %}
	{%- if arg.strlen and arg.intent != 'OUT' %}
		CALL C_F_STRING_PTR({{ arg.name }}, {{ arg.name }}_INTERN)
	{%- elif arg.ftype %}
		CALL C_F_POINTER({{ arg.name }}, {{ arg.name }}_INTERN)
	{%- endif %}
	{%- endfor %}
	{%- if function.ret.ftype %}
		ALLOCATE({{ export_name.upper() }}_INTERN)
	{%- endif %}
		{{ var_assign(function.ret, export_name.upper(), function.name + '(' + call_args(function.args, arg_names) + ')', True) }}
	END FUNCTION

{%- elif function.ret.getter == 'subroutine' %}

	SUBROUTINE {{ export_name.upper() }}({{ call_args(function.args) }}{% if function.args %}, {% endif %}{{ export_name.upper() }}_VALUE) BIND(C, NAME="{{ export_name }}")
	{%- for arg in function.args %}
		{{ var_decl(arg, arg.name, arg_names=arg_names, value=True) }}
	{%- endfor %}
		{{ var_decl(function.ret, export_name.upper() + '_VALUE', intent='OUT') }}
	{%- for arg in function.args %}
	{%- if arg.strlen and arg.intent != 'OUT' %}
		CALL C_F_STRING_PTR({{ arg.name }}, {{ arg.name }}_INTERN)
	{%- elif arg.ftype %}
		CALL C_F_POINTER({{ arg.name }}, {{ arg.name }}_INTERN)
	{%- endif %}
	{%- endfor %}
		{{ var_assign(function.ret, export_name.upper() + '_VALUE', function.name + '(' + call_args(function.args, arg_names) + ')', True) }}
	END SUBROUTINE
{%- endif %}
{%- endif %}
{%- endfor %}
{%- endif %}
END
