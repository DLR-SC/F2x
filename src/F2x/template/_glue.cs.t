{#-#################################################################################################################-#}
{#- F2x-Template: _glue.cs.t                                                                                        -#}
{#-                                                                                                                 -#}
{#- This template generates a wrapper around the exported Fortran types and routines to be used by C#. It uses      -#}
{#- PInvoke to call the BIND(C) interface from _glue.f90.t.                                                         -#}
{#-#################################################################################################################-#}
{%- import '_pinvoke_types.cs.tl' as type_lib -%}
{%- import '_pinvoke_funcs.cs.tl' as func_lib with context -%}
{%- set lib_name = config.get('generate', 'dll') -%}

// This file was generated by F2x using '_glue.cs.t'. Please do not edit manually.
namespace {{ config.get('generate', 'namespace') }} {
    using System;
    using System.Collections.Generic;
    using System.Runtime.InteropServices;
    using System.Text;

    using F2x.Glue;
{%- if config.has_section('csimport') %}
    {% for ns in config.options('csimport') %}
    using {{ ns }};
    {%- endfor  %}
{%- endif %}

{#-=================================================================================================================-#}
{#- Derived types                                                                                                   -#}
{%- for type in module.types %}

    ///////////////////////////////////////////////////////////////////////////////////////////////////////////////////////
    // TYPE {{ type.name }} from {{ module.name }}
    public class {{ type.name }} : F2Type {
        public {{ type.name }}() : base({{ type.name }}.New(), true) {
        }

        public {{ type.name }}(IntPtr ptr, Boolean owned=false) : base(ptr, owned) {
        }

        ~{{ type.name }}() {
            if (owned) {
                {{ type.name }}.Free(this.ptr);
                this.ptr = IntPtr.Zero;
                this.owned = false;
            }
        }

        {{ type_lib.copy(type) }}

        [DllImport("{{ lib_name }}", EntryPoint="{{ type.name }}_new")]
        private extern static IntPtr New();

        [DllImport("{{ lib_name }}", EntryPoint="{{ type.name }}_free")]
        private extern static void Free(IntPtr ptr);

    {%- for field in type.fields  %}

        {{ type_lib.import(type, field, lib_name) }}
    {%- endfor %}

    {%- for field in type.fields %}

        {{ type_lib.property(type, field) }}
    {%- endfor %}
    }
{%- endfor %}

{%- if config.has_section('export') %}
{%- set exports = config.options('export') %}

    public static class {{ module.name }} {
    {%- for sub in module.subroutines if sub.name.lower() in exports %}

        {{ func_lib.sub(config.get('export', sub.name.lower()), sub, lib_name) }}
    {%- endfor %}

    {%- for func in module.functions if func.name.lower() in exports %}
    {%- if func.ret.getter == 'function' %}

        {{ func_lib.func(config.get('export', func.name.lower()), func, lib_name) }}
    {%- elif func.ret.getter == 'subroutine' %}

        {{ func_lib.subfunc(config.get('export', func.name.lower()), func, lib_name) }}
    {%- endif %}
    {%- endfor %}
    }
{%- endif %}

}
