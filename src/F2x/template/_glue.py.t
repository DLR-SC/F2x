{#-#################################################################################################################-#}
{#- F2x-Template: _ctypes.py.t                                                                                      -#}
{#-                                                                                                                 -#}
{#- This template generates Python code that accesses the Fortran wrapper code that was produced by the             -#}
{#- _bindc.f90.t template.                                                                                          -#}
{#-#################################################################################################################-#}
{%- import "_ctypes_types.py.tl" as type_lib with context -%}
{%- import "_ctypes_funcs.py.tl" as func_lib with context -%}

# This file was generated by F2x using '_ctypes.py.t'. Please do not edit manually.
import ctypes
import os

{%- if config.has_section('pyimport') %}
{%- for import_module in config.options('pyimport') %}
from {{ import_module }} import {{ config.get('pyimport', import_module) }}
{%- endfor %}
{%- endif %}

from F2x.lib.py.glue import DerivedType, DynamicArray, DerivedTypeArray

_lib = '{{ config.get('generate', 'dll') }}'
_path = os.path.join(os.path.dirname(__file__), _lib)
{{ module.name }} = ctypes.cdll.LoadLibrary(_path)

{#-=================================================================================================================-#}
{#- Derived types                                                                                                   -#}
{%- for type in module.types %}

#----------------------------------------------------------------------------------------------------------------------
# TYPE({{ type.name }}) from {{ module.name }}
{{ type_lib.import(type) }}
class {{ type.name }}(DerivedType):
    _new = {{ module.name }}.{{ type.name }}_new
    _free = {{ module.name }}.{{ type.name }}_free

    {%- for field in type.fields %}
    {%- set prop = [] %}
    {{ type_lib.getter(type, field, prop) }}
    {{ type_lib.setter(type, field, prop) }}
    {{ type_lib.property(type, field, prop) }}
    {%- endfor %}

    def copy_from(self, other):
    {%- for field in type.fields %}
        self.{{ field.name }} = other.{{ field.name }}
    {%- endfor %}
#----------------------------------------------------------------------------------------------------------------------
{%- endfor %}


{#-=================================================================================================================-#}
{#- Exported subroutines and functions                                                                              -#}
{%- if config.has_section('export') %}
{%- set exports = config.options('export') %}

#---------------------------------------------------------------------------------------------------------------------
# Exported subroutines and functions
{#- Subroutines first, but only those that are exported. #}
{%- for sub in module.subroutines if sub.name.lower() in exports %}

{{ func_lib.routine(sub, config.get('export', sub.name.lower())) }}
{%- endfor %}

{#- Next the exported functions. #}
{%- for func in module.functions if func.name.lower() in exports %}
{%- if func.ret.getter == 'function' %}
{#- Only use function wrapper if return type can be returned this way... #}

{{ func_lib.function(func, config.get('export', func.name.lower())) }}
{%- else %}
{#- ... otherwise, we need a subroutine-function. #}

{{ func_lib.subfunc(func, config.get('export', func.name.lower())) }}
{%- endif %}
{%- endfor %}
#----------------------------------------------------------------------------------------------------------------------
{%- endif %}
