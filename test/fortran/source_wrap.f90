

MODULE SOURCE_WRAP
    USE C_INTERFACE_MODULE
    USE SOURCE

    IMPLICIT NONE
    PRIVATE

CONTAINS
    !===================================================================================================================
    ! TYPE(BASIC_TYPE)
    FUNCTION BASIC_TYPE_NEW() RESULT(PTR) BIND(C, name="BASIC_TYPE_new")
        TYPE(C_PTR) :: PTR
        TYPE(BASIC_TYPE), POINTER :: INSTANCE

        ALLOCATE(INSTANCE)
        PTR = C_LOC(INSTANCE)
    END FUNCTION

    SUBROUTINE BASIC_TYPE_FREE(PTR) BIND(C, name="BASIC_TYPE_free")
        TYPE(C_PTR), INTENT(IN), VALUE :: PTR
        TYPE(BASIC_TYPE), POINTER :: INSTANCE

        IF (.NOT. C_ASSOCIATED(PTR)) RETURN
        CALL C_F_POINTER(PTR, INSTANCE)
        IF (ASSOCIATED(INSTANCE)) DEALLOCATE(INSTANCE)
    END SUBROUTINE
    ! BASIC_TYPE%INTFIELD
    
    FUNCTION BASIC_TYPE_GET_INTFIELD(PTR) RESULT(INTFIELD) BIND(C, name="BASIC_TYPE_get_INTFIELD")
        TYPE(C_PTR), INTENT(IN), VALUE :: PTR
        TYPE(BASIC_TYPE), POINTER :: INSTANCE
        INTEGER :: INTFIELD

        IF (.NOT. C_ASSOCIATED(PTR)) THEN
            WRITE (*,*) "Cannot access INTFIELD from null pointer."
            RETURN
        END IF
        CALL C_F_POINTER(PTR, INSTANCE)
        INTFIELD = INSTANCE%INTFIELD
    END FUNCTION

    SUBROUTINE BASIC_TYPE_SET_INTFIELD(PTR, INTFIELD) BIND(C, name="BASIC_TYPE_set_INTFIELD")
        TYPE(C_PTR), INTENT(IN), VALUE :: PTR
        TYPE(BASIC_TYPE), POINTER :: INSTANCE
        INTEGER, INTENT(IN) :: INTFIELD

        IF (.NOT. C_ASSOCIATED(PTR)) THEN
            WRITE (*,*) "Cannot access INTFIELD from null pointer."
            RETURN
        END IF
        CALL C_F_POINTER(PTR, INSTANCE)
        INSTANCE%INTFIELD = INTFIELD
    END SUBROUTINE
    ! BASIC_TYPE%REALFIELD
    
    FUNCTION BASIC_TYPE_GET_REALFIELD(PTR) RESULT(REALFIELD) BIND(C, name="BASIC_TYPE_get_REALFIELD")
        TYPE(C_PTR), INTENT(IN), VALUE :: PTR
        TYPE(BASIC_TYPE), POINTER :: INSTANCE
        REAL(KIND=8) :: REALFIELD

        IF (.NOT. C_ASSOCIATED(PTR)) THEN
            WRITE (*,*) "Cannot access REALFIELD from null pointer."
            RETURN
        END IF
        CALL C_F_POINTER(PTR, INSTANCE)
        REALFIELD = INSTANCE%REALFIELD
    END FUNCTION

    SUBROUTINE BASIC_TYPE_SET_REALFIELD(PTR, REALFIELD) BIND(C, name="BASIC_TYPE_set_REALFIELD")
        TYPE(C_PTR), INTENT(IN), VALUE :: PTR
        TYPE(BASIC_TYPE), POINTER :: INSTANCE
        REAL(KIND=8), INTENT(IN) :: REALFIELD

        IF (.NOT. C_ASSOCIATED(PTR)) THEN
            WRITE (*,*) "Cannot access REALFIELD from null pointer."
            RETURN
        END IF
        CALL C_F_POINTER(PTR, INSTANCE)
        INSTANCE%REALFIELD = REALFIELD
    END SUBROUTINE
    ! BASIC_TYPE%LOGICALFIELD
    
    FUNCTION BASIC_TYPE_GET_LOGICALFIELD(PTR) RESULT(LOGICALFIELD) BIND(C, name="BASIC_TYPE_get_LOGICALFIELD")
        TYPE(C_PTR), INTENT(IN), VALUE :: PTR
        TYPE(BASIC_TYPE), POINTER :: INSTANCE
        LOGICAL :: LOGICALFIELD

        IF (.NOT. C_ASSOCIATED(PTR)) THEN
            WRITE (*,*) "Cannot access LOGICALFIELD from null pointer."
            RETURN
        END IF
        CALL C_F_POINTER(PTR, INSTANCE)
        LOGICALFIELD = INSTANCE%LOGICALFIELD
    END FUNCTION

    SUBROUTINE BASIC_TYPE_SET_LOGICALFIELD(PTR, LOGICALFIELD) BIND(C, name="BASIC_TYPE_set_LOGICALFIELD")
        TYPE(C_PTR), INTENT(IN), VALUE :: PTR
        TYPE(BASIC_TYPE), POINTER :: INSTANCE
        LOGICAL, INTENT(IN) :: LOGICALFIELD

        IF (.NOT. C_ASSOCIATED(PTR)) THEN
            WRITE (*,*) "Cannot access LOGICALFIELD from null pointer."
            RETURN
        END IF
        CALL C_F_POINTER(PTR, INSTANCE)
        INSTANCE%LOGICALFIELD = LOGICALFIELD
    END SUBROUTINE
    ! BASIC_TYPE%CHARFIELD
    
    SUBROUTINE BASIC_TYPE_GET_CHARFIELD(PTR, CHARFIELD) BIND(C, name="BASIC_TYPE_get_CHARFIELD")
        TYPE(C_PTR), INTENT(IN), VALUE :: PTR
        TYPE(BASIC_TYPE), POINTER :: INSTANCE
        TYPE(C_PTR), INTENT(OUT) :: CHARFIELD
        CHARACTER(32) :: CHARFIELD_INTERN

        IF (.NOT. C_ASSOCIATED(PTR)) THEN
            WRITE (*,*) "Cannot access CHARFIELD from null pointer."
            RETURN
        END IF
        CALL C_F_POINTER(PTR, INSTANCE)
        CHARFIELD = C_MALLOC(32_8 + 1)
        CALL F_C_STRING(INSTANCE%CHARFIELD, CHARFIELD)
    END SUBROUTINE

    SUBROUTINE BASIC_TYPE_SET_CHARFIELD(PTR, CHARFIELD) BIND(C, name="BASIC_TYPE_set_CHARFIELD")
        TYPE(C_PTR), INTENT(IN), VALUE :: PTR
        TYPE(BASIC_TYPE), POINTER :: INSTANCE
        TYPE(C_PTR), INTENT(IN) :: CHARFIELD
        CHARACTER(32) :: CHARFIELD_INTERN

        IF (.NOT. C_ASSOCIATED(PTR)) THEN
            WRITE (*,*) "Cannot access CHARFIELD from null pointer."
            RETURN
        END IF
        CALL C_F_POINTER(PTR, INSTANCE)
        CALL C_F_STRING(CHARFIELD, INSTANCE%CHARFIELD)
    END SUBROUTINE
    ! BASIC_TYPE%INTARRAY
    
    SUBROUTINE BASIC_TYPE_GET_INTARRAY(PTR, INTARRAY) BIND(C, name="BASIC_TYPE_get_INTARRAY")
        TYPE(C_PTR), INTENT(IN), VALUE :: PTR
        TYPE(BASIC_TYPE), POINTER :: INSTANCE
        TYPE(C_PTR), INTENT(OUT) :: INTARRAY
        INTEGER, DIMENSION(:), POINTER :: INTARRAY_INTERN

        IF (.NOT. C_ASSOCIATED(PTR)) THEN
            WRITE (*,*) "Cannot access INTARRAY from null pointer."
            RETURN
        END IF
        CALL C_F_POINTER(PTR, INSTANCE)
        INTARRAY_INTERN => INSTANCE%INTARRAY
        
        INTARRAY = C_LOC(INTARRAY_INTERN)
    END SUBROUTINE
    ! BASIC_TYPE%REALARRAY
    SUBROUTINE BASIC_TYPE_ALLOC_REALARRAY(PTR, SIZES) BIND(C, name="BASIC_TYPE_alloc_REALARRAY")
        TYPE(C_PTR), INTENT(IN), VALUE :: PTR
        TYPE(BASIC_TYPE), POINTER :: INSTANCE
        TYPE(C_PTR), INTENT(IN) :: SIZES
        INTEGER, DIMENSION(:), POINTER :: SIZE_ARRAY

        IF (.NOT. C_ASSOCIATED(PTR) .OR. .NOT. C_ASSOCIATED(SIZES)) RETURN
        CALL C_F_POINTER(PTR, INSTANCE)
        IF (ALLOCATED(INSTANCE%REALARRAY)) RETURN
        CALL C_F_POINTER(SIZES, SIZE_ARRAY, [1])
        ALLOCATE(INSTANCE%REALARRAY(SIZE_ARRAY(1)))
    END SUBROUTINE
    
    SUBROUTINE BASIC_TYPE_GET_REALARRAY(PTR, REALARRAY) BIND(C, name="BASIC_TYPE_get_REALARRAY")
        TYPE(C_PTR), INTENT(IN), VALUE :: PTR
        TYPE(BASIC_TYPE), POINTER :: INSTANCE
        TYPE(C_PTR), INTENT(OUT) :: REALARRAY
        REAL(KIND=8), DIMENSION(:), POINTER :: REALARRAY_INTERN

        IF (.NOT. C_ASSOCIATED(PTR)) THEN
            WRITE (*,*) "Cannot access REALARRAY from null pointer."
            RETURN
        END IF
        CALL C_F_POINTER(PTR, INSTANCE)
        REALARRAY_INTERN => INSTANCE%REALARRAY
        
        REALARRAY = C_LOC(REALARRAY_INTERN)
    END SUBROUTINE
    ! BASIC_TYPE%LOGICALARRAY
    SUBROUTINE BASIC_TYPE_ALLOC_LOGICALARRAY(PTR, SIZES) BIND(C, name="BASIC_TYPE_alloc_LOGICALARRAY")
        TYPE(C_PTR), INTENT(IN), VALUE :: PTR
        TYPE(BASIC_TYPE), POINTER :: INSTANCE
        TYPE(C_PTR), INTENT(IN) :: SIZES
        INTEGER, DIMENSION(:), POINTER :: SIZE_ARRAY

        IF (.NOT. C_ASSOCIATED(PTR) .OR. .NOT. C_ASSOCIATED(SIZES)) RETURN
        CALL C_F_POINTER(PTR, INSTANCE)
        IF (ASSOCIATED(INSTANCE%LOGICALARRAY)) RETURN
        CALL C_F_POINTER(SIZES, SIZE_ARRAY, [1])
        ALLOCATE(INSTANCE%LOGICALARRAY(SIZE_ARRAY(1)))
    END SUBROUTINE
    
    SUBROUTINE BASIC_TYPE_GET_LOGICALARRAY(PTR, LOGICALARRAY) BIND(C, name="BASIC_TYPE_get_LOGICALARRAY")
        TYPE(C_PTR), INTENT(IN), VALUE :: PTR
        TYPE(BASIC_TYPE), POINTER :: INSTANCE
        TYPE(C_PTR), INTENT(OUT) :: LOGICALARRAY
        LOGICAL, DIMENSION(:), POINTER :: LOGICALARRAY_INTERN

        IF (.NOT. C_ASSOCIATED(PTR)) THEN
            WRITE (*,*) "Cannot access LOGICALARRAY from null pointer."
            RETURN
        END IF
        CALL C_F_POINTER(PTR, INSTANCE)
        LOGICALARRAY_INTERN => INSTANCE%LOGICALARRAY
        
        LOGICALARRAY = C_LOC(LOGICALARRAY_INTERN)
    END SUBROUTINE

    !===================================================================================================================
    ! TYPE(COMPOUND_TYPE)
    FUNCTION COMPOUND_TYPE_NEW() RESULT(PTR) BIND(C, name="COMPOUND_TYPE_new")
        TYPE(C_PTR) :: PTR
        TYPE(COMPOUND_TYPE), POINTER :: INSTANCE

        ALLOCATE(INSTANCE)
        PTR = C_LOC(INSTANCE)
    END FUNCTION

    SUBROUTINE COMPOUND_TYPE_FREE(PTR) BIND(C, name="COMPOUND_TYPE_free")
        TYPE(C_PTR), INTENT(IN), VALUE :: PTR
        TYPE(COMPOUND_TYPE), POINTER :: INSTANCE

        IF (.NOT. C_ASSOCIATED(PTR)) RETURN
        CALL C_F_POINTER(PTR, INSTANCE)
        IF (ASSOCIATED(INSTANCE)) DEALLOCATE(INSTANCE)
    END SUBROUTINE
    ! COMPOUND_TYPE%BASICFIELD
    
    FUNCTION COMPOUND_TYPE_GET_BASICFIELD(PTR) RESULT(BASICFIELD) BIND(C, name="COMPOUND_TYPE_get_BASICFIELD")
        TYPE(C_PTR), INTENT(IN), VALUE :: PTR
        TYPE(COMPOUND_TYPE), POINTER :: INSTANCE
        TYPE(C_PTR) :: BASICFIELD
        TYPE(BASIC_TYPE), POINTER :: BASICFIELD_INTERN

        IF (.NOT. C_ASSOCIATED(PTR)) THEN
            WRITE (*,*) "Cannot access BASICFIELD from null pointer."
            RETURN
        END IF
        CALL C_F_POINTER(PTR, INSTANCE)
        BASICFIELD_INTERN => INSTANCE%BASICFIELD
        BASICFIELD = C_LOC(BASICFIELD_INTERN)
    END FUNCTION
    ! COMPOUND_TYPE%ALLOCATEFIELD
    SUBROUTINE COMPOUND_TYPE_ALLOC_ALLOCATEFIELD(PTR) BIND(C, name="COMPOUND_TYPE_alloc_ALLOCATEFIELD")
        TYPE(C_PTR), INTENT(IN), VALUE :: PTR
        TYPE(COMPOUND_TYPE), POINTER :: INSTANCE

        IF (.NOT. C_ASSOCIATED(PTR)) RETURN
        CALL C_F_POINTER(PTR, INSTANCE)
        IF (ALLOCATED(INSTANCE%ALLOCATEFIELD)) RETURN
        ALLOCATE(INSTANCE%ALLOCATEFIELD)
    END SUBROUTINE
    
    FUNCTION COMPOUND_TYPE_GET_ALLOCATEFIELD(PTR) RESULT(ALLOCATEFIELD) BIND(C, name="COMPOUND_TYPE_get_ALLOCATEFIELD")
        TYPE(C_PTR), INTENT(IN), VALUE :: PTR
        TYPE(COMPOUND_TYPE), POINTER :: INSTANCE
        TYPE(C_PTR) :: ALLOCATEFIELD
        TYPE(BASIC_TYPE), POINTER :: ALLOCATEFIELD_INTERN

        IF (.NOT. C_ASSOCIATED(PTR)) THEN
            WRITE (*,*) "Cannot access ALLOCATEFIELD from null pointer."
            RETURN
        END IF
        CALL C_F_POINTER(PTR, INSTANCE)
        ALLOCATEFIELD_INTERN => INSTANCE%ALLOCATEFIELD
        ALLOCATEFIELD = C_LOC(ALLOCATEFIELD_INTERN)
    END FUNCTION
    ! COMPOUND_TYPE%POINTERFIELD
    SUBROUTINE COMPOUND_TYPE_ALLOC_POINTERFIELD(PTR) BIND(C, name="COMPOUND_TYPE_alloc_POINTERFIELD")
        TYPE(C_PTR), INTENT(IN), VALUE :: PTR
        TYPE(COMPOUND_TYPE), POINTER :: INSTANCE

        IF (.NOT. C_ASSOCIATED(PTR)) RETURN
        CALL C_F_POINTER(PTR, INSTANCE)
        IF (ASSOCIATED(INSTANCE%POINTERFIELD)) RETURN
        ALLOCATE(INSTANCE%POINTERFIELD)
    END SUBROUTINE
    
    FUNCTION COMPOUND_TYPE_GET_POINTERFIELD(PTR) RESULT(POINTERFIELD) BIND(C, name="COMPOUND_TYPE_get_POINTERFIELD")
        TYPE(C_PTR), INTENT(IN), VALUE :: PTR
        TYPE(COMPOUND_TYPE), POINTER :: INSTANCE
        TYPE(C_PTR) :: POINTERFIELD
        TYPE(BASIC_TYPE), POINTER :: POINTERFIELD_INTERN

        IF (.NOT. C_ASSOCIATED(PTR)) THEN
            WRITE (*,*) "Cannot access POINTERFIELD from null pointer."
            RETURN
        END IF
        CALL C_F_POINTER(PTR, INSTANCE)
        POINTERFIELD_INTERN => INSTANCE%POINTERFIELD
        POINTERFIELD = C_LOC(POINTERFIELD_INTERN)
    END FUNCTION
    ! COMPOUND_TYPE%BASICARRAY
    SUBROUTINE COMPOUND_TYPE_ALLOC_BASICARRAY(PTR, SIZES) BIND(C, name="COMPOUND_TYPE_alloc_BASICARRAY")
        TYPE(C_PTR), INTENT(IN), VALUE :: PTR
        TYPE(COMPOUND_TYPE), POINTER :: INSTANCE
        TYPE(C_PTR), INTENT(IN) :: SIZES
        INTEGER, DIMENSION(:), POINTER :: SIZE_ARRAY

        IF (.NOT. C_ASSOCIATED(PTR) .OR. .NOT. C_ASSOCIATED(SIZES)) RETURN
        CALL C_F_POINTER(PTR, INSTANCE)
        IF (ALLOCATED(INSTANCE%BASICARRAY)) RETURN
        CALL C_F_POINTER(SIZES, SIZE_ARRAY, [1])
        ALLOCATE(INSTANCE%BASICARRAY(SIZE_ARRAY(1)))
    END SUBROUTINE
    
    SUBROUTINE COMPOUND_TYPE_GET_BASICARRAY(PTR, BASICARRAY) BIND(C, name="COMPOUND_TYPE_get_BASICARRAY")
        TYPE(C_PTR), INTENT(IN), VALUE :: PTR
        TYPE(COMPOUND_TYPE), POINTER :: INSTANCE
        TYPE(C_PTR), INTENT(OUT) :: BASICARRAY
        TYPE(BASIC_TYPE), DIMENSION(:), POINTER :: BASICARRAY_INTERN

        IF (.NOT. C_ASSOCIATED(PTR)) THEN
            WRITE (*,*) "Cannot access BASICARRAY from null pointer."
            RETURN
        END IF
        CALL C_F_POINTER(PTR, INSTANCE)
        BASICARRAY_INTERN => INSTANCE%BASICARRAY
        
        BASICARRAY = C_LOC(BASICARRAY_INTERN)
    END SUBROUTINE

    !===================================================================================================================
    ! Exported subroutines and functions

    ! SUBROUTINE BASIC_ARGS_IN
    SUBROUTINE SRC_BAI(ININT, INREAL, INLOGICAL) BIND(C, name="SRC_BAI")
        INTEGER, INTENT(IN) :: ININT
        REAL(KIND=8), INTENT(IN) :: INREAL
        LOGICAL, INTENT(IN) :: INLOGICAL
        
        CALL BASIC_ARGS_IN(ININT, INREAL, INLOGICAL)
        
    END SUBROUTINE
    

    ! SUBROUTINE BASIC_ARGS_OUT
    SUBROUTINE SRC_BAO(OUTINT, OUTREAL, OUTLOGICAL) BIND(C, name="SRC_BAO")
        INTEGER, INTENT(OUT) :: OUTINT
        REAL(KIND=8), INTENT(OUT) :: OUTREAL
        LOGICAL, INTENT(OUT) :: OUTLOGICAL
        
        CALL BASIC_ARGS_OUT(OUTINT, OUTREAL, OUTLOGICAL)
        
    END SUBROUTINE
    

    ! SUBROUTINE BASIC_ARGS_INOUT
    SUBROUTINE SRC_BAIO(INOUTINT, INOUTREAL, INOUTLOGICAL) BIND(C, name="SRC_BAIO")
        INTEGER, INTENT(INOUT) :: INOUTINT
        REAL(KIND=8), INTENT(INOUT) :: INOUTREAL
        LOGICAL, INTENT(INOUT) :: INOUTLOGICAL
        
        CALL BASIC_ARGS_INOUT(INOUTINT, INOUTREAL, INOUTLOGICAL)
        
    END SUBROUTINE
    

    ! SUBROUTINE BASIC_ARGS_ARRAY
    SUBROUTINE SRC_BAA(INARRAY, OUTARRAY, INOUTARRAY) BIND(C, name="SRC_BAA")
        TYPE(C_PTR), INTENT(IN) :: INARRAY
        INTEGER, DIMENSION(:), POINTER :: INARRAY_INTERN
        TYPE(C_PTR), INTENT(OUT) :: OUTARRAY
        INTEGER, DIMENSION(:), POINTER :: OUTARRAY_INTERN
        TYPE(C_PTR), INTENT(INOUT) :: INOUTARRAY
        INTEGER, DIMENSION(:), POINTER :: INOUTARRAY_INTERN
        
        CALL C_F_POINTER(INARRAY, INARRAY_INTERN, [3])
        CALL C_F_POINTER(OUTARRAY, OUTARRAY_INTERN, [3])
        CALL C_F_POINTER(INOUTARRAY, INOUTARRAY_INTERN, [3])
        CALL BASIC_ARGS_ARRAY(INARRAY_INTERN, OUTARRAY_INTERN, INOUTARRAY_INTERN)
        
        OUTARRAY = C_LOC(OUTARRAY_INTERN)
        INOUTARRAY = C_LOC(INOUTARRAY_INTERN)
    END SUBROUTINE
    

    ! SUBROUTINE BASIC_ARGS_NDARRAY
    SUBROUTINE SRC_BAN(INARRAY2D, OUTARRAY3D, INOUTARRAY2D) BIND(C, name="SRC_BAN")
        TYPE(C_PTR), INTENT(IN) :: INARRAY2D
        INTEGER, DIMENSION(:, :), POINTER :: INARRAY2D_INTERN
        TYPE(C_PTR), INTENT(OUT) :: OUTARRAY3D
        REAL(KIND=8), DIMENSION(:, :, :), POINTER :: OUTARRAY3D_INTERN
        TYPE(C_PTR), INTENT(INOUT) :: INOUTARRAY2D
        INTEGER, DIMENSION(:, :), POINTER :: INOUTARRAY2D_INTERN
        
        CALL C_F_POINTER(INARRAY2D, INARRAY2D_INTERN, [2, 3])
        CALL C_F_POINTER(OUTARRAY3D, OUTARRAY3D_INTERN, [1, 2, 3])
        CALL C_F_POINTER(INOUTARRAY2D, INOUTARRAY2D_INTERN, [2, 2])
        CALL BASIC_ARGS_NDARRAY(INARRAY2D_INTERN, OUTARRAY3D_INTERN, INOUTARRAY2D_INTERN)
        
        OUTARRAY3D = C_LOC(OUTARRAY3D_INTERN)
        INOUTARRAY2D = C_LOC(INOUTARRAY2D_INTERN)
    END SUBROUTINE
    

    ! SUBROUTINE STRING_ARGS
    SUBROUTINE SRC_BSA(INSTR, OUTSTR, INOUTSTR) BIND(C, name="SRC_BSA")
        TYPE(C_PTR), INTENT(IN) :: INSTR
        CHARACTER(32) :: INSTR_INTERN
        TYPE(C_PTR), INTENT(OUT) :: OUTSTR
        CHARACTER(32) :: OUTSTR_INTERN
        TYPE(C_PTR), INTENT(INOUT) :: INOUTSTR
        CHARACTER(32) :: INOUTSTR_INTERN
        
        CALL C_F_STRING(INSTR, INSTR_INTERN)
        CALL C_F_STRING(OUTSTR, OUTSTR_INTERN)
        CALL C_F_STRING(INOUTSTR, INOUTSTR_INTERN)
        CALL STRING_ARGS(INSTR_INTERN, OUTSTR_INTERN, INOUTSTR_INTERN)
        
        OUTSTR = C_MALLOC(32_8 + 1)
        CALL F_C_STRING(OUTSTR_INTERN, OUTSTR)
        CALL F_C_STRING(INOUTSTR_INTERN, INOUTSTR)
    END SUBROUTINE
    

    ! SUBROUTINE DERIVED_TYPE_ARGS
    SUBROUTINE SRC_DTA(INTYPE, OUTTYPE, INOUTTYPE) BIND(C, name="SRC_DTA")
        TYPE(C_PTR), INTENT(IN) :: INTYPE
        TYPE(BASIC_TYPE), POINTER :: INTYPE_INTERN
        TYPE(C_PTR), INTENT(OUT) :: OUTTYPE
        TYPE(BASIC_TYPE), POINTER :: OUTTYPE_INTERN
        TYPE(C_PTR), INTENT(INOUT) :: INOUTTYPE
        TYPE(BASIC_TYPE), POINTER :: INOUTTYPE_INTERN
        
        CALL C_F_POINTER(INTYPE, INTYPE_INTERN)
        CALL C_F_POINTER(OUTTYPE, OUTTYPE_INTERN)
        CALL C_F_POINTER(INOUTTYPE, INOUTTYPE_INTERN)
        CALL DERIVED_TYPE_ARGS(INTYPE_INTERN, OUTTYPE_INTERN, INOUTTYPE_INTERN)
        
        OUTTYPE = C_LOC(OUTTYPE_INTERN)
        INOUTTYPE = C_LOC(INOUTTYPE_INTERN)
    END SUBROUTINE
    

    ! FUNCTION BASIC_RETURN_VALUE
    FUNCTION SRC_BRV() BIND(C, name="SRC_BRV")
        INTEGER :: SRC_BRV
        
        SRC_BRV = BASIC_RETURN_VALUE()
        
    END FUNCTION
    

    ! FUNCTION DERIVED_TYPE_RETURN_VALUE
    FUNCTION SRC_DTRV() BIND(C, name="SRC_DTRV")
        TYPE(C_PTR) :: SRC_DTRV
        TYPE(BASIC_TYPE), POINTER :: SRC_DTRV_INTERN
        
        ALLOCATE(SRC_DTRV_INTERN)
        SRC_DTRV_INTERN = DERIVED_TYPE_RETURN_VALUE()
        
        
        SRC_DTRV = C_LOC(SRC_DTRV_INTERN)
    END FUNCTION
    

    ! FUNCTION STRING_RETURN_VALUE
    SUBROUTINE SRC_SRV(SRC_SRV_OUT) BIND(C, name="SRC_SRV")
        TYPE(C_PTR), INTENT(OUT) :: SRC_SRV_OUT
        CHARACTER(32) :: SRC_SRV_OUT_INTERN
        
        SRC_SRV_OUT_INTERN = STRING_RETURN_VALUE()
        
        
        SRC_SRV_OUT = C_MALLOC(32_8 + 1)
        CALL F_C_STRING(SRC_SRV_OUT_INTERN, SRC_SRV_OUT)
    END SUBROUTINE
    

    ! FUNCTION ARRAY_RETURN_VALUE
    FUNCTION SRC_ARV() BIND(C, name="SRC_ARV")
        TYPE(C_PTR) :: SRC_ARV
        INTEGER, DIMENSION(:), POINTER :: SRC_ARV_INTERN
        
        ALLOCATE(SRC_ARV_INTERN(3))
        SRC_ARV_INTERN = ARRAY_RETURN_VALUE()
        
        
        SRC_ARV = C_LOC(SRC_ARV_INTERN)
    END FUNCTION
    
END